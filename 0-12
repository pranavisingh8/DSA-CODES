SPACES:
%{
#include <stdio.h>

int totalCharCount = 0, tabCount = 0, spaceCount = 0;
%}

%%
[ \t]+                   {
                            if (yytext[0] == '\t') tabCount += yyleng;  // Count tabs
                            else spaceCount += yyleng;                  // Count spaces
                        }

\n                       { /* Newlines don't count as characters or spaces */ }

.                        { totalCharCount++; }  // Count all other characters

%%

int yywrap() { return 1; }

int main() {
    yylex();

    printf("Total Chars      : %d\n", totalCharCount);
    printf("Total Spaces     : %d\n", spaceCount);
    printf("Total Tabs       : %d\n", tabCount);

    return 0;
}


TOKEN:
%{
#include <stdio.h>
#include <string.h>

int tokenCount = 0;

char *keywords[] = {
    "int", "float", "if", "else", "void", "char", "double",
    "for", "while", "return", "main"
};
int keywordTotal = 11;

int isKeyword(char *token) {
    for (int i = 0; i < keywordTotal; i++) {
        if (strcmp(keywords[i], token) == 0)
            return 1;
    }
    return 0;
}
%}

%%
\/\/[^\n]*               { /* Ignore single-line comments */ }
\/\*([^*]|\*+[^*/])*\*\/ { /* Ignore multi-line comments */ }

[a-zA-Z_][a-zA-Z0-9_]*   { tokenCount++; }  // Identifiers and keywords

[0-9]+                   { tokenCount++; }  // Numbers

\"[^\"]*\"               { tokenCount++; }  // String literals

[+\-*/=<>!&|^%(){};,.]    { tokenCount++; }  // Operators and punctuation

[ \t\n]+                 { /* Ignore spaces, tabs, and newlines */ }

.                        { /* Ignore any other non-matching characters */ }

%%

int yywrap() { return 1; }

int main() {
    yylex();

    printf("Total Tokens    : %d\n", tokenCount);

    return 0;
}


FREQ:


DEC TO BINARY:
%{
#include <stdio.h>
#include <stdlib.h>

void dec_to_bin(long n) {
    if (n == 0) {
        printf("0");
        return;
    }
    int binary[64], i = 0;
    while (n > 0) {
        binary[i++] = n % 2;
        n /= 2;
    }
    for (int j = i - 1; j >= 0; j--)
        printf("%d", binary[j]);
}
%}

%%
[0-9]+    {
              long num = atol(yytext);
              printf("Decimal: %ld\tBinary: ", num);
              dec_to_bin(num);
              printf("\n");
           }
[ \t\n]+   ;
.          ;
%%
int yywrap() {return 1;}
int main() {
    yylex();
    return 0;
}

HEX TO DEC:
%{
#include <stdio.h>
#include <stdlib.h>

void hex_to_decimal(const char *text) {
    long decimal = strtol(text, NULL, 16);
    printf("Hex: %s\tDecimal: %ld\n", text, decimal);
}
%}

%%

[0-9a-fA-F]+   { hex_to_decimal(yytext); }


[ \t\n]+       ;
.              ;
%%

int main() {
    yylex();  // Start scanning input
    return 0;
}

int yywrap() {
    return 1;
}

INFIX TO POSTFIX.y:
infix.y:



Programming constructs:
icc.l:
%{
#include "ic.tab.h"
%}

%%

[0-9]+              { yylval.ival = atoi(yytext); return NUMBER; }
[a-zA-Z_][a-zA-Z0-9_]* { yylval.sval = strdup(yytext); return ID; }
"if"                { return IF; }
"else"              { return ELSE; }
"while"             { return WHILE; }
"=="                { return EQ; }
"!="                { return NEQ; }
"<"                 { return LT; }
"<="                { return LE; }
">"                 { return GT; }
">="                { return GE; }
"true"              { return TRUE; }
"false"             { return FALSE; }
"+"                 { return '+'; }
"-"                 { return '-'; }
"*"                 { return '*'; }
"/"                 { return '/'; }
"="                 { return '='; }
"("                 { return '('; }
")"                 { return ')'; }
";"                 { return ';'; }
"\n"                { return '\n'; }
[ \t]+              { /* skip whitespace */ }
.                   { printf("Unknown character: %s\n", yytext); }

%%

int yywrap() { return 1; }


icc.y:

%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int tempCount = 0;
char tempName[10];

int yylex();
void yyerror(const char *s);

char* newTemp() {
    sprintf(tempName, "t%d", tempCount++);
    return strdup(tempName);
}
%}

%union {
    char* sval;
    int ival;
}

%token <sval> ID
%token <ival> NUMBER
%token IF ELSE WHILE TRUE FALSE
%token EQ NEQ LT LE GT GE
%token '+' '-' '*' '/' '='
%token '(' ')' ';' '\n'

%right '='
%left '+' '-'
%left '*' '/'
%type <sval> expr

%%

program:
    expr_list
;

expr_list:
    expr '\n' { printf("Final Result: %s\n", $1); }
  | expr_list expr '\n' { printf("Final Result: %s\n", $2); }
  ;

expr:
    ID '=' expr {
        printf("%s = %s\n", $1, $3);
        $$ = $1;      // result is the variable name
    }
  | expr '+' expr {
        char* t = newTemp();
        printf("%s = %s + %s\n", t, $1, $3);
        $$ = t;
    }
  | expr '-' expr {
        char* t = newTemp();
        printf("%s = %s - %s\n", t, $1, $3);
        $$ = t;
    }
  | expr '*' expr {
        char* t = newTemp();
        printf("%s = %s * %s\n", t, $1, $3);
        $$ = t;
    }
  | expr '/' expr {
        char* t = newTemp();
        printf("%s = %s / %s\n", t, $1, $3);
        $$ = t;
    }
  | '(' expr ')' { $$ = $2; }
  | ID          { $$ = $1; }     // bare variable: just return name
  | NUMBER {
        char* t = newTemp();
        printf("%s = %d\n", t, $1);
        $$ = t;
    }

  | IF '(' expr ')' stmt {
        char* labelTrue = newTemp();
        char* labelFalse = newTemp();
        printf("if %s goto %s\n", $3, labelTrue);
        printf("goto %s\n", labelFalse);
        printf("%s:\n", labelTrue);
        $$ = $6; // result of the statement in true block
        printf("%s:\n", labelFalse);
    }
  | IF '(' expr ')' stmt ELSE stmt {
        char* labelTrue = newTemp();
        char* labelFalse = newTemp();
        printf("if %s goto %s\n", $3, labelTrue);
        printf("goto %s\n", labelFalse);
        printf("%s:\n", labelTrue);
        $$ = $6;
        printf("goto %s\n", labelFalse);
        printf("%s:\n", labelFalse);
        $$ = $8; // result of the statement in false block
    }
  | WHILE '(' expr ')' stmt {
        char* labelStart = newTemp();
        char* labelEnd = newTemp();
        printf("%s:\n", labelStart);
        printf("if %s goto %s\n", $3, labelEnd);
        printf("goto %s\n", labelStart);
        printf("%s:\n", labelEnd);
        $$ = $5;  // result of the while statement
    }
  | TRUE  { $$ = strdup("true"); }
  | FALSE { $$ = strdup("false"); }

stmt:
    expr { $$ = $1; }
  | '{' expr_list '}' { $$ = $2; }
;

%%

void yyerror(const char *s) {
    fprintf(stderr, "Syntax Error: %s\n", s);
}

int main() {
    printf("Enter arithmetic expression:\n");
    while (!feof(stdin)) yyparse();
    return 0;
}


